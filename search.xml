<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hashCode()与equals()</title>
    <url>/2020/09/19/hashCode()%E4%B8%8Eequals()/</url>
    <content><![CDATA[<h4 id="1-1-和equals的区别"><a href="#1-1-和equals的区别" class="headerlink" title="1.1 ==和equals的区别"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_128-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB">1.1 ==和equals的区别</a></h4><p><strong><code>==</code></strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(<strong>基本数据类型==比较的是值，引用数据类型==比较的是内存地址</strong>)</p>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<p><code>Object</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 <code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li>情况 2：类覆盖了 <code>equals()</code>方法。一般，我们都覆盖 <code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</li>
<li>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</li>
</ul>
<p><code>String</code>类<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h4 id="1-2-hashCode-与-equals"><a href="#1-2-hashCode-与-equals" class="headerlink" title="1.2 hashCode()与 equals()"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_129-hashcode%E4%B8%8E-equals">1.2 hashCode()与 equals()</a></h4><p>“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p>
<p><strong>1)hashCode()介绍:</strong></p>
<p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>2)为什么要有 hashCode？</strong></p>
<p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>
<blockquote>
<p><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p>
<p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>
<p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p>
<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>
]]></content>
      <categories>
        <category>JAVA源码解读</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>免费从 0 到 1搭建个人博客网站</title>
    <url>/2020/09/19/%E5%85%8D%E8%B4%B9%E4%BB%8E%200%20%E5%88%B0%201%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>#使用 Hexo 框架来搭建个人网站<br>这两天我重新整理了一下自己的 Blog ，因为我之前用的 Octopress 框架，有些年头了，一些主题和插件并不是很多。<br>后来对比了几个框架，发现 Hexo 不错，和 Octopress 差不多，也是可以用 Markdown 写文章，然后生成静态网站，Hexo 主题丰富一些。<br>Hexo 是基于 nodejs 的，搭建起来很简单。那么接下来就说说如何从 0 开始使用 Hexo 搭建个人博客吧。</p>
<p>#开始搭建<br>因为 hexo 是基于 node 框架的，所以呢，我们首先需要下载安装node，下载地址：<a href="https://nodejs.cn/">https://nodejs.cn/</a><br>安装完之后，我们打开命令窗口，输入 node -v ，如果返回下图所示，那么就说明你安装 node 成功了。</p>
<p>#node 版本</p>
<p>安装成功后，我们在命令行窗口运行如下命令来安装 hexo：<br>npm install hexo-cli -g<br>初始化博客目录：<br>hexo init xxx.github.io (这里的xxx换成你自己的英文名)<br>初始化完成后，我们就进入我们的目录：<br>cd xxx.github.io<br>安装<br>npm install<br>clean一下，然后生成静态页面<br>hexo clean<br>hexo g<br>g 就是generate ,生成的意思<br>把你的网站运行起来<br>hexo s<br>s 就是server ，在服务上运行的意思<br>打开你的浏览器，输入 localhost:4000 。自此，你的个人网站就这么速度的搭建起来了！</p>
<p>#优化 hexo 博客主题<br>进入你的网站目录，打开 _config 文件，这个文件是用来配置你的网站信息的。<br>这里列出我的简单配置，具体可以看这个Hexo配置文档：<a href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a><br>title: java，python，教程<br>subtitle: liuwei<br>description: xx的个人博客，主要涉及到编程（Java，Python，Linux等），个人提升学习，视频教程<br>keywords: java，python，教程<br>author: wistbean<br>language: zh<br>选一个Hexo主题<br>刚搭建完的网站，是不是觉得有点丑，不符合你的漂亮的脸庞？反正我是这么觉得的，那么就选一个主题来装饰一下吧，在这里可以选择你要的主题，知乎答主们推荐的hexo主题大全：<a href="https://www.zhihu.com/question/24422335">https://www.zhihu.com/question/24422335</a></p>
<p>#下载Hexo主题<br>慢慢挑，选择好了你的主题之后，就可以下载主题资源了，比如我这里选择一个 NEXT 主题来演示一下，在你的目录中输入以下命令：<br>git clone <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>这里主要就是将主题下载到我们的themes目录下。</p>
<p>#配置主题<br>主题下载完之后，在你根目录下的 _config.yml 文件中，修改 theme 为你的主题名字：<br>theme: next<br>重新生成和运行<br>hexo g<br>hexo s<br>访问一下看看，是不是比之前好看多了？</p>
<p>hexo next主题</p>
<p>hexo博客的第一篇文章，打上标签和分类<br>你已经把你的网站打扮的漂亮大方简洁惹人爱了，那么接下来就要好好去写内容了，内容才是重要的。</p>
<p>#两种方式来新建你的博文<br>命令形式<br>在你的 blog 目录下使用如下命令：<br>hexo new article （这里的article写上你的文章的名称）<br>输入这样的命令之后你的 source/_posts 下就会生成一个 article.md 文件，在这个文件下就可以写上你的博客内容了。<br>用 Markdown 的语法去写。<br>直接新建方式<br>直接点的方式就是直接在source/_posts新建一个 Markdown 文件，其实和命令形式是一个道理，只不过命令形式用了命令来创建。推荐使用命令的方式，毕竟 Geek 一点。</p>
<p>给你的文章打上标签<br>在你的博客中打标签能让你的文章方便检索。<br>hexo打开标签功能：<br>hexo new page tags<br>这时候你的 source/ 下生成 tags/index.md 文件，我们将其打开，然后把它改成：<br>type: “tags”<br>comments: false<br>这时候你要为你的文章打上标签就可以在文章的头部写上：<br>tags:<br>    - Tag1<br>    - Tag2<br>    - Tag3<br>比如我现在的这篇文章打的标签就是这样的：<br>tags:<br>    - 个人网站<br>    - 教程<br>    - hexo<br>    - blog<br>    - Git<br>    - Nginx<br>#给你的文章添加分类<br>分类，归档，是你博客的特性之一。把文章分门别类，方便查看。<br>打开hexo分类功能：<br>hexo new page categories<br>同样的，你的 source 目录下生成 categories/index.md 文件，我们将其打开，把它改成：<br>type: “categories”<br>comments: false<br>这时候你就可以给你的文章归类存档了，使用方式就是在你的文章的头部加上：<br>categories:<br>         - 分类1<br>         - 分类2<br>比如我现在的这篇文章的分类就是这样的：<br>categories:<br>    - 个人网站<br>    - 教程<br>注意：标签和分类要确定你的配置文件 _config.yml 是否有打开了 tag_dir: tags 和 category_dir: categories。另外，Markdown 的语法是写作最优雅最简洁最简单的，如果之前没用过的建议去学一下Markdown 语法说明，一般一个钟左右就能掌握。因为它和 HTML 那样简单。<br>给你的文章添加评论<br>当别人看了你的文章，有问题想跟你探讨，没评论怎么行？评论也是你的 Blog 交互的重要方式之一。<br>现在很多 hexo 主题都内置了第三方评论的系统。比较常用的有：<br>多说 ：<a href="http://duoshuo.com/">http://duoshuo.com/</a><br>畅言 ：<a href="https://changyan.kuaizhan.com/">https://changyan.kuaizhan.com/</a><br>Valine：<a href="https://github.com/xcss/Valine">https://github.com/xcss/Valine</a><br>Disqus：<a href="https://disqus.com/">https://disqus.com/</a><br>友言: <a href="http://www.uyan.cc/">http://www.uyan.cc/</a><br>gitment: <a href="https://github.com/imsun/gitment">https://github.com/imsun/gitment</a><br>自己去看一下，喜欢哪个用哪个，自己的 Blog 就是要自由。<br>选好你的评论系统之后，进入平台注册后，平台会给你一个 APPID 和 appkey。拿到这些信息到你的主题下的配置文件下设置。<br>以 next 主题和畅言评论为例：进入你的themes/next,打开_config.yml，定位到 changyan ，把 enable 改为 true。<br>changyan:<br>  enable: true<br>  appid: 这里写上你的畅言在appid<br>  appkey: 这里写上你的畅言在appkey<br>设置好之后，重新clean生成一下就有评论啦：<br>hexo clean<br>hexo g<br>hexo s<br>打开你的预览连接看看你的文章下方，已经有评论功能啦。如下图就是我博客的评论功能：</p>
<p>评论</p>
<p>让全世界的人都认识你<br>已经搞定了个人blog，接下来当然是要部署到网上让人家访问了，如果不想花钱，可以使用GitHub Pages，使用它就可以部署自己的网站啦。<br>对于 GitHub 不知道怎么用的童鞋，可以看一下我的这个教程：GitHub完全使用指南：<a href="https://vip.fxxkpython.com/?cat=6">https://vip.fxxkpython.com/?cat=6</a></p>
<p>创建 Github pages 仓库<br>接着创建一个 xxx.github.io 的 public 仓库，这里的xxx写你的名字，比如我写的是 wistbean.github.io，那么到时我就可以通过 wistbean.github.io 来访问我的网站了。<br>创建完成之后，那么你就有自己的 Git 地址了。</p>
<p>安装 hexo-deployer-git<br>在你的博客目录下输入如下命令，这样你在本地写的文章才能 push 到 GitHub 上面去。<br>npm install hexo-deployer-git –save</p>
<p>配置你的Git<br>打开你的配置文件，然后输入你的 git 地址：<br>deploy:<br>    type: git<br>    repo: <a href="https://github.com/xxx/xxxx.github.io.git">https://github.com/xxx/xxxx.github.io.git</a><br>推送你的网站到Github上<br>直接输入命令 ：hexo d<br>d 就是 deploy ， 部署上去的意思。<br>访问你的网站<br>这样push上去之后，你就可以直接在浏览器输入你的 xxx.github.io 就可以访问啦！<br>要有点个性，绑上你的域名<br>如果你不喜欢千篇一律的 xx.github.io 域名，可以自己绑定一个自己的域名。<br>购买域名<br>关于域名的购买我比较推荐去 dynadot 或者 godaddy，这是国外的域名商，可以使用支付宝购买，不需要备案，使用起来不错的。绑定<br>买完你的域名之后，接下来几个步骤轻松搞定：<br>添加 CNAME 文件<br>在你的博客的 sources 目录下新建一个 CNAME 文件，这个文件里面就写你的域名就可以了，比如：<a href="http://www.xxxx.com./">www.xxxx.com。</a> 接着将文件push到你的 GitHub上，可以使用 hexo d 命令。<br>在你的域名商后台进行 DNS 解析添加两条记录：</p>
<ol>
<li><p>主机记录：@<br> 记录类型：A<br> 记录值：192.30.252.154 或者 192.30.252.153</p>
</li>
<li><p>主机记录：www<br>  记录类型：CNAME<br>  记录值：xxx.github.io  (这里就是你的github仓库名称)<br>GitHub 设置域名<br>在你的 GitHub 设置域名，在你的 GitHub 博客项目中点击 Settings，在 GitHub Pages 下的 Custom domain 写上你的域名，然后 save。</p>
</li>
</ol>
<p>GitHub 设置域名</p>
<p>至此，你已经搭建好了自己的博客，托管你的网站到 GitHub 了，也绑定了你自己的域名了，那么这时候你的网站就可以被全世界的人看到了。</p>
]]></content>
      <categories>
        <category>个人博客网站</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载的生命周期</title>
    <url>/2020/09/19/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a><a href="">类的生命周期</a></h1><p>一个类的完整生命周期如下：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" alt="img"></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><a href="">类加载过程</a></h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p>
<p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><a href="">加载</a></h3><p>类加载过程的第一步，主要完成下面3件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li>
</ol>
<p>虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p>
<p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p>
<p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p>
<p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><a href="">验证</a></h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png" alt="验证阶段示意图"></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><a href="">准备</a></h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li>
</ol>
<p><strong>基本数据类型的零值：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><a href="">解析</a></h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="">初始化</a></h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code> ()</code>方法的过程。</p>
<p>对于<code>（）</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>（）</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p>
<p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>
<ol>
<li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul>
<li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li>
<li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li>
<li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a><a href="">卸载</a></h2><p>卸载类即该类的Class对象被GC。</p>
<p>卸载类需要满足3个要求:</p>
<ol>
<li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被GC</li>
</ol>
<p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
]]></content>
      <categories>
        <category>JAVA源码解读</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
